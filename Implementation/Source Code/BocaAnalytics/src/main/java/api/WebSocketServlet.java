/*
 * @author Adrian Lopez Quesada
 * @version v0.1.1-alpha
 */

package api;

import controller.Controller;
import controller.GroundTruthController;
import controller.VideoAnalisisController;
import datatransferobject.DtoGroundTruth;
import datatransferobject.DtoVideoAnalisis;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Observable;
import java.util.Observer;



import javax.websocket.CloseReason;
import javax.websocket.EndpointConfig;
import javax.websocket.OnClose;
import javax.websocket.OnError;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;



// TODO: Auto-generated Javadoc
/**
 * The Class WebSocketServlet.
 * The purpose is to communicate the Java Logic for processing a video with an html UI.
 * It uses a Jetty's JSR-356 WebSocket to establish a connection with one User.
 * This methods inside this class can't be tested by themselves,
 * they get executed when an external client calls them as a WEBSOCKET.
 * Thats why some parameters as Session can't be manually sent, they are generated by Jetty's 
 * automated webScoket connection and configuration with one client.   
 */
@ServerEndpoint("/vidUpload")
public class WebSocketServlet implements Observer {

  /** The uploaded file.
   * A File type attribute that will be used to manage
   * the transfer of bytes that belongs to a video and 
   * generate a file from them. It is used as a class 
   * attribute for future cases, now it doesn´t servers a
   * function  */
  private static File uploadedFile = null;
  
  /** The file stream.
   *  FileOutputstream used by the uploadedFile to direct the bytes
   *  it receives into a specific path on the server, its highly
   *  associated with the uploadedFile, only used for Output of the file*/
  
  private FileOutputStream fileStream = null;
  
  /** The file name of the uploadFile.
   * String of the file sent by the user, used for the GroundTruth
   * and/or locating the specific file from a user  */
  private String fileName = null;
  
  /** The path of the server.
   *  Its a string containing the path inside the server,
   *  where all the files are uploaded. Its used to fecth the videos
   *  for processing*/
  private String path = "src/main/webapp/VideoFiles/";

  /** The session of the client.
   * Object of type Session, its generated automatically by the JETTY framework
   * Its used to send messages back to the client, can't be created, its send on
   * everycall. */
  private Session session = null;
  
  /** The first File in boolean
   * Its a Boolean that becomes true when a Grountruth is being processed.
   * Its main function is to redirect the flow of the program to the GroundTruth Analysis. */
  private boolean firstFilein = false;
  

  /** The ground file name.
   * String containing the name of the grundtruth file.
   * Since the Groundtruth needs two files, as the second video is uploaded
   * we need to store the path of the first one. */
  private String groundFileName;
  
  
  /**
   * Open.
   * Method executed automatically when a session is opened
   * A session is open when an external client access the URL /vidUpload
   * as a WebSocket Consumer. Its only used to assign the class attribute session 
   * @param session the current user's session
   *     its a configuration Object generated by the Jetty Framework by the 
   *     data sent by the clients connection. 
   * @param conf the configuration sent by the client, its never used but its needed
   *     for the standard Jetty needs
   */
  @OnOpen
  public void openSession(Session session, EndpointConfig conf) {
    this.session = session;
  }

  /**
   * Process upload.
   * Method executed when a client sends an buffer of bytes. By
   *     using the @OnMessage Jetty knows this method receives data and
   *     when it determines the client is sending a byteBuffer, jetty calls
   *     this method. The method is used to write the the chunks of the file 
   *     sent by the client, using the attribute fileStream. 
   * @param msg the ByteBuffer (type) of bytes sent by the client, it depends on
   *     the clients upload speed to determine the size sent.
   * @param last the boolean parameter needed for the standard defined by the 
   *     Jetty JSR-356, its never used.
   * @param session the Session (type) of the client who is sending the file or ByteBuffer
   */
  @OnMessage(maxMessageSize = 2048 * 2048)
  public void processUpload(ByteBuffer msg, boolean last, Session session) {      

    while (msg.hasRemaining()) {    //while something is remaining in the buffer     
      try {
        fileStream.write(msg.get()); //writes the chunk sent
      } catch (IOException exc) {               
        exc.printStackTrace();
      }
    }

  }

  /**
   * On message.
   * Method executed when a message comes from the client, by the tag @OnMessage
   *     jetty knows it has to call this method when a message that is only a String not 
   *     a ByteBuffer is sent. This method receives the name of the file that is going to 
   *     be transfered and dependng on the final message when the file is uploaded, it 
   *     decides between GroundTruth or video analysis.
   * @param session the Session(type) of the client sending the message
   *     this parameter is used to send back messages to the client if necessary
   * @param msg the message sent by the client
   */
  @OnMessage(maxMessageSize = 2048 * 2048)
  public void onMessage(Session session, String msg) {
    if (!msg.equals("end") && !msg.equals("groundTruth")) { //any other message sent
      fileName = msg.substring(msg.indexOf(':') + 1); //we know its the file name
      uploadedFile = new File(path + fileName); //we create the new file
      try {
        fileStream = new FileOutputStream(uploadedFile); //we createthe Stream to save data
      } catch (FileNotFoundException exc) {     
        exc.printStackTrace();
      }
    } else { //the file transfer ended
      try {
        fileStream.flush(); //flushes the remaining data of the file
        fileStream.close(); //closes the stream for security and access reasons
      } catch (IOException exc) {       
        exc.printStackTrace();
      }
      if (msg.equals("end")) { //its a normal video processor
        processingActivity(session);
      } else { //Grountruth analysis
        if (!firstFilein) { //its the first file uploaded
          firstFilein = true; //the firstFilein is already in
          groundFileName = path + fileName;  //saves the path of the Groundtruth
          try {
            session.getBasicRemote().sendText("groundTruth"); //sends'groundTruth' to the client
          } catch (IOException exc) {
            exc.printStackTrace();
          }
        } else { //the first file was already in
          processingGroundTruth(session); //initiates the GroundTruth processing.
        }
      }
    }
  }

  /**
   * Close.
   * Method executed when a client's session is closed,
   *     its executed automatically when the connection is closed manually or by error
   *     used to restart the groudntruth boolean firstFilein and to print in console
   *     about the sessions reason of closing.
   * @param session the Session (type) of a client which session has been closed.
   * @param reason the CloseReason (type) reason why it closed, normally a manual disconnection
   *     from the client, Jetty sends both parameters.
   */
  @OnClose
  public void close(Session session, CloseReason reason) {
    firstFilein = false;
    System.out.println("socket closed: " + reason.getReasonPhrase());
  }

  /**
   * Error.
   * A type of catch within a socket's connection, its used by default
   *     and should be used with an error Handling class to log the errors
   * @param session the Session (type) of a client's session that generated
   *     an error 
   * @param throwable the Throwable (type) object sent by Jetty to handle de error
   *     its never used and the error should be handled by and errorHandler class, 
   *     not this throwable
   */
  @OnError
  public void error(Session session, Throwable throwable) {
    throwable.printStackTrace();

  }
  
  /**
   * Process video.
   * Private method to process the video, it initializes the controller for 
   * the specific purpose and sends a DTO object containing the path to the file
   * @param ses the Session (type) from the client, its passed by parameter
   *     gotten from the onMessage method.
   * @return the dto (DtoVideoAnalisis) containing the new URL to access the processed video.
   */
  private DtoVideoAnalisis processVideo(Session ses) {
    DtoVideoAnalisis vid = new DtoVideoAnalisis();
    vid.setVideoPath(path + fileName); //combines path + filename
    vid.setOutVideoPath(path); // seths output path
    Controller videoProcessor = new VideoAnalisisController(); //init controller
    videoProcessor.addObserver(this); //add this class as an observer for the video process
    return (DtoVideoAnalisis)videoProcessor.algoritm(vid); // executes the algorithm 
    //and returns the DTO
  }
    
  /**
   * Process download.
   * Private method that sends the download link to the client
   *     it sends the url form the 16 char and on, since the html
   *     client can't access the whole server. Like this: substring(16).
   * @param ses the Session (type) of the client that sent the video.
   *     its passed form the onMessage method.
   * @param path the DTOVideoAnalisis which contains the new path of the
   *     processed video
   */
  private void processDownload(Session ses, DtoVideoAnalisis path) {
    String pathStr = path.getOutVideoPath();
    pathStr = pathStr.substring(16); //substring so html can access the file
    try {
      ses.getBasicRemote().sendText(pathStr); // sends path
    } catch (IOException exc) {
      // TODO Auto-generated catch block
      exc.printStackTrace();
    }
  }
    
  /**
   * Processing activity.
   * Method to encapsulate all the process activities.
   * @param session the Session (type) of the client, its received by the
   *     OnMessage method.
   */
  private void processingActivity(Session session) {
    DtoVideoAnalisis path = processVideo(session);
    processDownload(session, path);
  }
  
  /**
   * Processing ground truth.
   * Method that assembles the controller of the Grountruth and the
   *     the DTO it needs for the analysis. It also sends the Dice value that was
   *     generated
   * @param ses the Session(type) of the current client, it gets the param from
   *     the OnMessage method
   */
  private void processingGroundTruth(Session ses) {
    DtoGroundTruth vid = new DtoGroundTruth(); //init DTO
    vid.setVideoPath(path + fileName); //combines full server path
    vid.setGrundVideoPath(groundFileName); // sets GroudnTruth file
    Controller truthProcessor = new GroundTruthController(); //init controller
    truthProcessor.addObserver(this); // add this class as an observer for update status
    DtoGroundTruth dto = (DtoGroundTruth) truthProcessor.algoritm(vid); // starts the algorithm
    try {
      ses.getBasicRemote().sendText(dto.getDiceValue() + ""); // sends dice value
    } catch (IOException exc) {
      // TODO Auto-generated catch block
      exc.printStackTrace();
    }
  }
  
  /* (non-Javadoc)
   * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
   */
  
  /**
   * Update on notify.
   * Method from implementing observer, it is used for the VideoProcessor class to send 
   *     status reports of the current video process so that the client has ifnromation
   *     about it.
   * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
   * @param o the Observable object that sent the status change notification
   * @param arg the array sent by the observable with parameters
   *     it is not used in this case
   */  
  public void update(Observable o, Object arg) {
    //este metodo no puede cumplir el estandar por seguir la implementacion de la interface
    try {
      session.getBasicRemote().sendText("transfer");//sends transfer message so the UI can update
    } catch (IOException exc) {
      // TODO Auto-generated catch block
      exc.printStackTrace();
    }
  }
}
